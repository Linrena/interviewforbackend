## 最长连续子序列

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

要求：O(n)时间复杂度解决

**思路**：利用set对nums去重并生成集合，在集合中判断一个数是否存在等操作可以实现O（1）时间复杂度；遍历集合，如果该元素-1的数在集合中，证明由它往上组成的最长连续子序列肯定不是长的，指教跳过，否则自增判断是否在集合中，计算最大长度。

```python
class Solution:
    def longestConsecutive(self, nums):
        longest_streak = 0
        num_set = set(nums)

        for num in num_set:
            if num - 1 not in num_set:
                current_num = num
                current_streak = 1

                while current_num + 1 in num_set:
                    current_num += 1
                    current_streak += 1

                longest_streak = max(longest_streak, current_streak)

        return longest_streak
```

##  最长递增子序列的个数

在未排序的数组中找到严格递增的子序列，求最长的子序列的个数。

**思路**
定义状态
dp[i]：到nums[i]为止的最长递增子序列长度
count[i]：到nums[i]为止的最长递增子序列个数
初始化状态
dp = [1] * n：代表最长递增子序列的长度至少为1
count = [1] * n：代表最长递增子序列的个数至少为1
状态转移
对于每一个数nums[i]，看在它之前的数nums[j](0<= j < i)是否比当前数nums[i]小，如果nums[i] > nums[j]，那么相当于到nums[j]为止的最长递增子序列长度到nums[i]增加了1，到nums[i]为止的最长递增子序列长度就变成了dp[i] = dp[j] + 1；但是因为满足nums[i] > nums[j] 的nums[j]不止一个，dp[i]应该取这些dp[j] + 1的最大值，并且这些dp[j] + 1还会有相等的情况，一旦相等，到nums[i]为止的最长递增子序列个数就应该增加了。因此，具体的状态转移如下，在nums[i] > nums[j]的大前提下：
如果dp[j] + 1 > dp[i]，说明最长递增子序列的长度增加了，dp[i] = dp[j] + 1，长度增加，数量不变 count[i] = count[j]
如果dp[j] + 1 == dp[i]，说明最长递增子序列的长度并没有增加，但是出现了长度一样的情况，数量增加 count[i] += count[j]
记录最长递增子序列的最大长度max_length
遍历dp数组，如果dp数组记录的最大长度dp[i]等于max_length，将对应的数量count[i]加到结果res中

```Python
class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1: return 1
        dp = [1] * n  # 到nums[i]为止的最长递增子序列长度
        count = [1] * n  # 到nums[i]为止的最长递增子序列个数
        max_length = 0
        for i in range(1, n):
            for j in range(i):
                if nums[i] > nums[j]:
                    if dp[j] + 1 > dp[i]:
                        dp[i] = dp[j] + 1
                        count[i] = count[j]
                    elif dp[j] + 1 == dp[i]
                    	count[i] += count[j]
            max_length = max(max_length, dp[i])

        res = 0
        for i in range(n):
            if dp[i] == max_length
            	res += count[i]
        return res
```
复杂度分析

时间复杂度：O(n ^ 2)
空间复杂度：O(n)

## 三数之和

采用三指针法，第一指针从0遍历，第二指针在第一指针后面，第三指针从数组尾巴倒序遍历

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        nums.sort()
        ans = list()
        # 枚举 a
        for first in range(n):
            # 需要和上一次枚举的数不相同
            if first > 0 and nums[first] == nums[first - 1]:
                continue
            # c 对应的指针初始指向数组的最右端
            third = n - 1
            target = -nums[first]
            # 枚举 b
            for second in range(first + 1, n):
                # 需要和上一次枚举的数不相同
                if second > first + 1 and nums[second] == nums[second - 1]:
                    continue
                # 需要保证 b 的指针在 c 的指针的左侧，退出循环可能是second == third，也可能是<=target
                while second < third and nums[second] + nums[third] > target:
                    third -= 1
                # 如果指针重合，随着 b 后续的增加
                # 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
                if second == third:
                    break
                if nums[second] + nums[third] == target:
                    ans.append([nums[first], nums[second], nums[third]])
        
		return ans
```

## 组合总数

给定一个**无重复元素**的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合（答案不能包含重复组合）。

candidates 中的数字在一个组合中可以无限制重复被选取。

思路：排序数组，从左往右遍历数组元素进行深度搜索，一个元素可以被使用或者被跳过，排序数组可以对深度递归进行剪枝。注意到该数组是无重复元素的，那么答案中不会出现重复的组合。

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        n = len(candidates)
        ans = []
        candidates.sort()  # asc
        def dfs(target, combine, index):
            if target == 0: 
                ans.append(combine)
                return
            if index == n: return 
            if target - candidates[index] >= 0:
                dfs(target, combine, index + 1)
                dfs(target - candidates[index], combine + [candidates[index]], index)
        dfs(target, [], 0)
        return ans
```

## 组合总数2

给定一个数组 candidates （**可含有重复值**）和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 

**思路**：在上一题的基础上，对于candidates我们要做一个每个值出现次数的统计，然后以（value, count）的元组信息存储在列表中再排序，遍历过程中对于每一个元组中的value，我们可以取0到most次，其中most = min(target // freq\[index][0], freq\[index][1]), 取得最多次数的和不能超过剩下的target更不能超过该数出现的总次数。

```python
def combinationSum2(candidates: List[int], target: int) -> List[List[int]]:
        ans = []
        freq = sorted(collections.Counter(candidates).items())  # 计算每个数出现的次数，然后并排序
        n = len(freq)
        def dfs(target, combine, index):
            if target == 0:
                ans.append(combine)
                return 
            if index == n or target < freq[index][0]:
                return
            most = min(target // freq[index][0], freq[index][1])
            for i in range(most + 1):
                dfs(target - i * freq[index][0], combine + [freq[index][0]] * i, index + 1)
        dfs(target, [], 0)
        return ans
```

## 数组第一个缺失正整数

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？

```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        for i in range(n):
            if nums[i] <= 0:
                nums[i] = n + 1
        
        for i in range(n):
            num = abs(nums[i])
            if num <= n:
                nums[num - 1] = -abs(nums[num - 1])
        
        for i in range(n):
            if nums[i] > 0:
                return i + 1
        
        return n + 1

```

## 最长公共子序列

给定两个字符串str1和str2，输出连个字符串的最长公共子序列。如过最长公共子序列为空，则输出-1

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[m][n] if dp[m][n] != 0 else -1
```

## 数组逆序对计算

利用归并排序计算数组里不同的逆序对数，时间复杂度O(nlogn)

```python
def merge_count(list):
    if len(list) <= 1:
        return list, 0
    mid = len(list) // 2
    left_li,left_cont = merge_count(list[:mid])
    right_li,right_cont = merge_count(list[mid:])
    count = left_cont + right_cont

    result = []
    while 0 < len(left_li) and 0 < len(right_li):
        if left_li[0] > right_li[0]:
            result.append(left_li.pop(0))
            count += len(right_li)
        else:
            result.append(right_li.pop(0))
    result += left_li
    result += right_li
    return result, count
```

## 在有重复的升序数组中寻找特定的数的下标，如果有多个符合，返回最小下标，不在数组中返回-1

二分查找，记录下标

```python
def search(nums, target):
    ans = -1
    def recursive(left, right): 
        if left < 0 or right >= len(nums) or left > right:
            return
        mid = (right - left + 1) // 2 + left
        if nums[mid] == target:
            while mid-1 >= 0 and nums[mid-1] == target:
                mid -= 1
            nonlocal ans
            ans = mid
            return 
        recursive(left, mid-1)
        recursive(mid+1, right)
    recursive(0, len(nums)-1)
    return ans
print(search([1, 2, 4, 4, 5], 1))
```

## 全排列实现

递归实现

```python
def permutations(arr, position, end):
    if position == end:
        print(arr)
        return
    else:
        for index in range(position, end):
            # swap value
            arr[index], arr[position] = arr[position], arr[index]
            permutations(arr, position+1, end)
            # swap again
            arr[index], arr[position] = arr[position], arr[index]
 
arr = ["a","b","c"]
permutations(arr, 0, len(arr))
```

深度优先搜索回溯

```python
arr = ["a","b","c"]
n = len(arr)
visit = [True] * n  # choose if True
temp = [""] * n
def dfs(position):
    if position == n:
        print(temp)
        return
    for index in range(n):
        if visit[index] == True:
            temp[position] = arr[index]
            visit[index] = False
            dfs(position + 1)
            visit[index] = True
 
dfs(0)
```
