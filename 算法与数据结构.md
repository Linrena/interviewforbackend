## 二叉树，二叉搜索树，二叉平衡树，红黑树，B树，B+树

## 1、二叉树（Binary Tree）

二叉树是每个节点最多有两个子节点的树。
二叉树的叶子节点有0个字节点，二叉树的根节点或者内部节点有一个或者两个字节点。

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODQ3NDA4LzIwMTgxMS84NDc0MDgtMjAxODExMjYyMTIxMzE1ODAtODc5NjEwMzI2LnBuZw" alt="img" style="zoom:50%;" />

## 2、二叉搜索树（Binary Search Tree）

二叉搜索树， 又叫 二叉查找树，

它或者是一棵空树，或者是具有下列性质的二叉树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树。
  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODQ3NDA4LzIwMTgxMS84NDc0MDgtMjAxODExMjYyMjM5NTg2ODUtMzQ2OTM0NzMzLnBuZw" alt="img" style="zoom:50%;" />

## 3、平衡二叉树（AVL Tree）

平衡二叉树 全称叫做 `平衡二叉搜索（排序）树`，简称 AVL树。

AVL树：二叉查找树+平衡

AVL树的特性：

- 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，
- 左右两个子树 也都是一棵平衡二叉树。

在AVL树中，任何节点的两个子树的高度最大差别为 `1` ，所以它也被称为平衡二叉树 。

**如下图：**
根节点左边高度是3，因为左边最多有3条边；右边高度而2，相差1。
根节点左边的节点50的左边是1条边，高度为1，右边有两条边，高度为2，相差1。
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODQ3NDA4LzIwMTgxMS84NDc0MDgtMjAxODExMjYyMTMyMjg5OTItMTcyMTYyNDU5Ny5wbmc" alt="img" style="zoom:50%;" />

## 4、红黑树（Red-Black Tree）

红黑树是一种含有红、黑结点，并能自平衡的二叉查找树，其性质如下：

1、每个结点或是红色的，或是黑色的
2、根节点是黑色的
3、每个叶结点（NIL）是黑色的
4、如果一个节点是红色的，则它的两个儿子都是黑色的。
5、对于每个结点，从该结点到其叶子结点构成的所有路径上的黑结点个数相同。

<img src="https://img-blog.csdnimg.cn/20190820134050324.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9qaW4yMWNlbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

## 5、B树（Balance tree）

B树，也叫 B tree、B-树、B_树。

B树是一种平衡的多路查找树、m阶树 (m>=3)

B树的定义：

1、根结点至少有两个子节点；

2、每个非叶子节点（根节点除外）最少有m/2个子节点，即内部节点的子节点个数最少也有m/2个。

3、根节点最少有两个子节点。

4、有k个关键字(关键字按递增次序排列)的非叶结点恰好有k+1个孩子。

5、所有叶子节点在同一层，即所有叶子几点高度一致。

如下图（B树的内部节点可以存放数据，类似ZK的中间节点一样。B树不是每个节点都有足够多的子节点）

<img src="https://img-blog.csdnimg.cn/20190820134105371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9qaW4yMWNlbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

## 6、B+树（B+ tree）

B+树是从B树的变体。
跟B树的不同：

1、B+树非叶子节点不存放数据，只存放keys（索引数据）。
2、B+树的叶子节点之间存在指针相连，而且是单链表。

如下图（其实B+树上二叉搜索树的扩展，二叉搜索树是每次一分为二，B树是每次一分为多）

现代操作系统中，磁盘的存储结构使用的是B+树机制，mysql的innodb引擎的存储方式也是B+树机制

<img src="https://img-blog.csdnimg.cn/20190820134121153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9qaW4yMWNlbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

## 二叉树前中后序遍历，层序遍历

```python
import copy
class node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

# 简单的非递归实现二叉树的前序遍历  root -> left -> right
def preOrder_easy(root):
    res, stack = [], [root]
    while stack:
        root = stack.pop()
        if type(root) is node:
            if root.right:
                stack.append(root.right)
            if root.left:
                stack.append(root.left)
            stack.append(root.val)
        else:
            res.append(root)
    return res

preOrder_easy(copy.deepcopy(root))

# 后序遍历的非递归实现  left -> right -> root
def postOrder_easy(root):
    res, stack = [], [root]
    while stack:
        root = stack.pop()
        if type(root) is node:
            stack.append(root.val)
            if root.right:
                stack.append(root.right)
            if root.left:
                stack.append(root.left)
        else:
            res.append(root)
    return res
postOrder_easy(copy.deepcopy(root))

# 中序遍历非递归的简单实现   left -> root -> right
def inOrder_easy(root):
    res, stack = [], [root]
    while stack:
        root = stack.pop()
        if type(root) is node:
            if root.right:
                stack.append(root.right)
            stack.append(root.val)
            if root.left:
                stack.append(root.left)
        else:
            res.append(root)
    return res
inOrder_easy(copy.deepcopy(root))

# 层序遍历非递归实现记得不是采用栈而是采用队列，先进先出的数据结构，这样都是从左往右一层一层打印
def leverOrder_easy(root):
    res, queue = [], [root]
    while queue:
        curr = queue.pop(0)
        res.append(curr.val)
        if curr.left:
            queue.append(curr.left)
        if curr.right:
            queue.append(curr.right)
    return ans

# 递归实现最为简单，根据出现的顺序递归就好了，反而上面的栈实现主要栈是后进先出所以顺序要反过来
def preOrder_recur(root):
    if not root:
        return []
    return preOrder_recur(root.val) + preOrder_recur(root.left) + preOrder_recur(root.right)

def inOrder_recur(root):
    if not root:
        return []
    return inOrder_recur(root.left) + [root.val] + inOrder_recur(right)

def postOrder_recur(root):
    if not root:
        return []
    return postOrder_recur(root.left) + postOrder_recur(root.right) + postOrder_recur(root.val)

def levelOrder_recur(root):
    ans = [[]]  # 初始化时候就要添加一个二级列表，这样新层的第一个元素的值就有空间可以存储，相应的返回答案的时候不要最后一行
    def recursion(curr, level):
        if not curr:
            return 
        else:
            ans[level-1].append(curr.val)
            if len(ans) == level:
                ans.append([])  # 为下一层准备
            recursion(curr.left, level+1)  # 不用判断是否存在子结点再递归，递归的时候会先判断的
            recursion(curr.right, level+1)
    recursion(root, 1)
    return ans[:-1]
```

## 二叉树转链表

```python
给定一个二叉树，原地将它展开为一个单链表。
例如，给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6
1
2
3
4
5
将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
可以发现顺序刚好是二叉树的前序遍历顺序，前序遍历先访问左子树，所以不能将左指针用来连接链表，于是采用右指针来当做链表的指针
然后非递归实现的时候，先入右结点，这样的话刚好右指针被保存起来，用来链接连接链表，所以前序遍历非递归实现刚好可以原地将二叉树转为单链表
# 存一个辅助结点来表示上一个结点，这样遍历到下一个结点的时候可以让上一个结点的右指针指向自己
helpNode = None
def binTree_link(root):
    stack = [root]
    while stack:
        curr = stack.pop()
        if curr.right:
            stack.append(curr.right)
        if curr.left:
            stack.append(curr.left)
        if helpNode:
            helpNode.right = curr
            helpNode.left = None
        helpNode = curr
    return root
```



## 用两个栈实现队列

把所有数据往栈1插入，然后所有数据往栈2插入，出来的结果就是队列的效果，当然中途临时加元素，只能所有数据从栈2出来之后再重复之前的操作（比较无聊的问题）

## 数组逆序对计算

利用归并排序计算数组里不同的逆序对数，时间复杂度O(nlogn)

```python
def merge_count(list):
    if len(list) <= 1:
        return list, 0
    mid = len(list) // 2
    left_li,left_cont = merge_count(list[:mid])
    right_li,right_cont = merge_count(list[mid:])
    count = left_cont + right_cont

    result = []
    while 0 < len(left_li) and 0 < len(right_li):
        if left_li[0] > right_li[0]:
            result.append(left_li.pop(0))
            count += len(right_li)
        else:
            result.append(right_li.pop(0))
    result += left_li
    result += right_li
    return result, count
```

## 在有重复的升序数组中寻找特定的数的下标，如果有多个符合，返回最小下标，不在数组中返回-1

二分查找，记录下标

```python
def search(nums, target):
    ans = -1
    def recursive(left, right): 
        if left < 0 or right >= len(nums) or left > right:
            return
        mid = (right - left + 1) // 2 + left
        if nums[mid] == target:
            while mid-1 >= 0 and nums[mid-1] == target:
                mid -= 1
            nonlocal ans
            ans = mid
            return 
        recursive(left, mid-1)
        recursive(mid+1, right)
    recursive(0, len(nums)-1)
    return ans
print(search([1, 2, 4, 4, 5], 1))
```

## 全排列实现

递归实现

```python
def permutations(arr, position, end):
    if position == end:
        print(arr)
        return
    else:
        for index in range(position, end):
            # swap value
            arr[index], arr[position] = arr[position], arr[index]
            permutations(arr, position+1, end)
            # swap again
            arr[index], arr[position] = arr[position], arr[index]
 
arr = ["a","b","c"]
permutations(arr, 0, len(arr))
```

深度优先搜索回溯

```python
arr = ["a","b","c"]
n = len(arr)
visit = [True] * n  # choose if True
temp = [""] * n
def dfs(position):
    if position == n:
        print(temp)
        return
    for index in range(n):
        if visit[index] == True:
            temp[position] = arr[index]
            visit[index] = False
            dfs(position + 1)
            visit[index] = True
 
dfs(0)
```

## 卡特兰数

<img src="./shortcuts/image-20210408093403685.png" alt="image-20210408093403685" style="zoom: 80%;" />

### 经典的卡特兰数问题

### 括号匹配问题

- ![[公式]](https://www.zhihu.com/equation?tex=n) 个左括号， ![[公式]](https://www.zhihu.com/equation?tex=n) 个右括号，对于每一个位置，左括号数大于等于右括号数的方案总数。

- 等价于 ![[公式]](https://www.zhihu.com/equation?tex=n) 个 ![[公式]](https://www.zhihu.com/equation?tex=1) ， ![[公式]](https://www.zhihu.com/equation?tex=n) 个 ![[公式]](https://www.zhihu.com/equation?tex=-1) ，每个位置前缀和大于等于 ![[公式]](https://www.zhihu.com/equation?tex=0) 的方案总数。

- 两种理解方向：

- - ![[公式]](https://www.zhihu.com/equation?tex=f%5Bn%5D%3D%5Csum%5Climits_%7Bi%3D0%7D%5E%7Bn-1%7Df%5Bi%5Df%5Bn-1-i%5D)*。*枚举第一次前缀和为 ![[公式]](https://www.zhihu.com/equation?tex=0) 的位置，假如第 ![[公式]](https://www.zhihu.com/equation?tex=2x) 个点为第一次前缀和为 ![[公式]](https://www.zhihu.com/equation?tex=0) 的点，则固定第一个数为 ![[公式]](https://www.zhihu.com/equation?tex=1) ，第 ![[公式]](https://www.zhihu.com/equation?tex=x) 个数为 ![[公式]](https://www.zhihu.com/equation?tex=-1) ，则对答案贡献为 ![[公式]](https://www.zhihu.com/equation?tex=f%5Bx-1%5D%2Af%5Bn-x%5D) 。
  - ![[公式]](https://www.zhihu.com/equation?tex=f%5Bn%5D%3DC_%7B2n%7D%5En-C_%7B2n%7D%5E%7Bn-1%7D) 。总方案数为 ![[公式]](https://www.zhihu.com/equation?tex=C_%7B2n%7D%5En) ，现需求不符合条件的方案数，将问题转化为网格上的折线问题。第 ![[公式]](https://www.zhihu.com/equation?tex=i) 次在 ![[公式]](https://www.zhihu.com/equation?tex=%28i%2Cj%29) 处，第 ![[公式]](https://www.zhihu.com/equation?tex=i%2B1) 次在 ![[公式]](https://www.zhihu.com/equation?tex=%28i%2B1%2Cj%2B1%29) 或 ![[公式]](https://www.zhihu.com/equation?tex=%28i%2B1%2Cj-1%29) 处，终点为 ![[公式]](https://www.zhihu.com/equation?tex=%282n%2C0%29) 。不符合条件则说明折线上出现了 ![[公式]](https://www.zhihu.com/equation?tex=%28x%2C-1%29) 这个点， ![[公式]](https://www.zhihu.com/equation?tex=x) 为第一次到达 ![[公式]](https://www.zhihu.com/equation?tex=-1) 的点，我们将 ![[公式]](https://www.zhihu.com/equation?tex=x) 点之后的折线沿 ![[公式]](https://www.zhihu.com/equation?tex=y%3D-1) 对称过来，则终点为 ![[公式]](https://www.zhihu.com/equation?tex=%282n%2C-2%29) ，则一共有 ![[公式]](https://www.zhihu.com/equation?tex=n-1) 个 ![[公式]](https://www.zhihu.com/equation?tex=1) ， ![[公式]](https://www.zhihu.com/equation?tex=n%2B1) 个 ![[公式]](https://www.zhihu.com/equation?tex=-1) ，即不合法的方案总数为 ![[公式]](https://www.zhihu.com/equation?tex=C_%7B2n%7D%5E%7Bn-1%7D) ，因此 ![[公式]](https://www.zhihu.com/equation?tex=f%5Bn%5D%3DC_%7B2n%7D%5En-C_%7B2n%7D%5E%7Bn-1%7D) 。

<img src="https://pic1.zhimg.com/80/v2-7239cd587cc59c3fccca198728c1d220_1440w.jpg" alt="img" style="zoom: 33%;" />

### 出栈次序问题

- 一个无穷大的栈，进栈序列为 ![[公式]](https://www.zhihu.com/equation?tex=1%2C2%2C3...n) ，求有多少个不同的出栈序列。

### 多边划分为三角形问题

- 将一个凸多边形区域分成三角形区域的方案数。
- 在圆上选择 ![[公式]](https://www.zhihu.com/equation?tex=2%2An) 个点，将这些点对连接起来使得所得到的 ![[公式]](https://www.zhihu.com/equation?tex=n) 条线段不想交的方案数。

### 二叉树计数问题

- 给定 ![[公式]](https://www.zhihu.com/equation?tex=n) 个节点，能构成多少种形状不同的二叉树。
- 先取一个点作为顶点，然后左边依次可以取 ![[公式]](https://www.zhihu.com/equation?tex=0%EF%BD%9En-1) 个点，右边则可以取 ![[公式]](https://www.zhihu.com/equation?tex=n-1%EF%BD%9E0) 个点，相乘再累加即可得到答案。

## 海盗分金问题

经济学上有个“海盗分金”模型：是说5个[海盗](https://baike.baidu.com/item/海盗/161939)抢得100枚金币，他们按抽签的顺序依次提方案：首先由1号提出分配方案，然后5人表决，投票要超过半数同意方案才被通过，否则他将被扔入大海喂鲨鱼，依此类推。“海盗分金”其实是一个高度简化和[抽象](https://baike.baidu.com/item/抽象/82058)的模型，体现了[博弈](https://baike.baidu.com/item/博弈/74592)的思想。在“海盗分金”模型中，任何“分配者”想让自己的方案获得通过的关键是事先考虑清楚“挑战者”的分配方案是什么，并用最小的代价获取最大收益，拉拢“挑战者”分配方案中最不得意的人们。

### 假设前提

假定“每个海盗都是绝顶聪明且很理智”，那么“第一个海盗提出怎样的分配方案才能够使自己的收益最大化？”

### 推理过程

推理过程是这样的：

从后向前推，如果1至3号强盗都喂了[鲨鱼](https://baike.baidu.com/item/鲨鱼/40174)，只剩4号和5号的话，5号一定投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号惟有支持3号才能保命。

3号知道这一点，就会提出“100，0，0”的分配方案，对4号、5号一毛不拔而将全部金币归为已有，因为他知道4号一无所获但还是会投赞成票，再加上自己一票，他的方案即可通过。

不过，2号推知3号的方案，就会提出“98，0，1，1”的方案，即放弃3号，而给予4号和5号各一枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望他出局而由3号来分配。这样，2号将拿走98枚金币。

同样，2号的方案也会被1号所洞悉，1号并将提出（97，0，1，2，0）或（97，0，1，0，2）的方案，即放弃2号，而给3号一枚金币，同时给4号（或5号）2枚金币。由于1号的这一方案对于3号和4号（或5号）来说，相比2号分配时更优，他们将投1号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入囊中。这无疑是1号能够获取最大收益的方案了！答案是：1号强盗分给3号1枚金币，分给4号或5号强盗2枚，自己独得97枚。**分配方案可写成（97，0，1，2，0）或（97，0，1，0，2）**。

## 布隆过滤器

直观的说，bloom算法类似一个hash set，用来判断某个元素（key）是否在某个集合中。
和一般的hash set不同的是，这个算法无需存储key的值，对于每个key，只需要k个比特位，每个存储一个标志，用来判断key是否在集合中。

算法：
\1. 首先需要k个hash函数，每个函数可以把key散列成为1个整数
\2. 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0
\3. 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1
\4. 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。

**优点：不需要存储key，节省空间**

**缺点：**
**\1. 算法判断key在集合中时，有一定的概率key其实不在集合中**
**\2. 无法删除**

典型的应用场景：
某些存储系统的设计中，会存在空查询缺陷：当查询一个不存在的key时，需要访问慢设备，导致效率低下。
比如一个前端页面的缓存系统，可能这样设计：先查询某个页面在本地是否存在，如果存在就直接返回，如果不存在，就从后端获取。但是当频繁从缓存系统查询一个页面时，缓存系统将会频繁请求后端，把压力导入后端。

这时只要增加一个bloom算法的服务，后端插入一个key时，在这个服务中设置一次
需要查询后端时，先判断key在后端是否存在，这样就能避免后端的压力。

## 卡诺图（38译码器）

**有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有 10 只小白鼠和一星期的时间，如何检验出哪个瓶子里有毒药？**

根据2^10=1024，所以10个老鼠可以确定1000个瓶子具体哪个瓶子有毒。具体实现跟3个老鼠确定8个瓶子原理一样。
000=0
001=1
010=2
011=3
100=4
101=5
110=6
111=7
一位表示一个老鼠，0-7表示8个瓶子。也就是分别将1、3、5、7号瓶子的药混起来给老鼠1吃，2、3、6、7号瓶子的药混起来给老鼠2吃，4、5、6、7号瓶子的药混起来给老鼠3吃，哪个老鼠死了，相应的位标为1。如老鼠1死了、老鼠2没死、老鼠3死了，那么就是101=5号瓶子有毒。
同样道理10个老鼠可以确定1000个瓶子。
