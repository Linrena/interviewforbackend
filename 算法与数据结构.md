## [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        judge_set = set()
        ans = 0
        n = len(s)
        j = -1
        for i in range(n):
            if i != 0:
                judge_set.remove(s[i-1])
            while j + 1 < n and s[j+1] not in judge_set:
                judge_set.add(s[j+1])
                j += 1
            ans = max(ans, j - i + 1)
        return ans
```

## 左叶子结点和

```python
class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        isLeafNode = lambda node: not node.left and not node.right

        def dfs(node: TreeNode) -> int:
            ans = 0
            if node.left:
                ans += node.left.val if isLeafNode(node.left) else dfs(node.left)
            if node.right and not isLeafNode(node.right):
                ans += dfs(node.right)
            return ans
        
        return dfs(root) if root else 0
```

## 三数之和

采用三指针法，第一指针从0遍历，第二指针在第一指针后面，第三指针从数组尾巴倒序遍历

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        nums.sort()
        ans = list()
        
        # 枚举 a
        for first in range(n):
            # 需要和上一次枚举的数不相同
            if first > 0 and nums[first] == nums[first - 1]:
                continue
            # c 对应的指针初始指向数组的最右端
            third = n - 1
            target = -nums[first]
            # 枚举 b
            for second in range(first + 1, n):
                # 需要和上一次枚举的数不相同
                if second > first + 1 and nums[second] == nums[second - 1]:
                    continue
                # 需要保证 b 的指针在 c 的指针的左侧，退出循环可能是second == third，也可能是<=target
                while second < third and nums[second] + nums[third] > target:
                    third -= 1
                # 如果指针重合，随着 b 后续的增加
                # 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
                if second == third:
                    break
                if nums[second] + nums[third] == target:
                    ans.append([nums[first], nums[second], nums[third]])
        
		return ans
```

## 最长公共子序列

给定两个字符串str1和str2，输出连个字符串的最长公共子序列。如过最长公共子序列为空，则输出-1

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[m][n] if dp[m][n] != 0 else -1
```

## 二叉树前序遍历与中序遍历结果构造二叉树

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        def myBuildTree(preorder_left: int, preorder_right: int, inorder_left: int, inorder_right: int):
            if preorder_left > preorder_right:
                return None
            
            # 前序遍历中的第一个节点就是根节点
            preorder_root = preorder_left
            # 在中序遍历中定位根节点
            inorder_root = index[preorder[preorder_root]]
            
            # 先把根节点建立出来
            root = TreeNode(preorder[preorder_root])
            # 得到左子树中的节点数目
            size_left_subtree = inorder_root - inorder_left
            # 递归地构造左子树，并连接到根节点
            # 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
            root.left = myBuildTree(preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1)
            # 递归地构造右子树，并连接到根节点
            # 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
            root.right = myBuildTree(preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right)
            return root
        
        n = len(preorder)
        # 构造哈希映射，帮助我们快速定位根节点
        index = {element: i for i, element in enumerate(inorder)}
        return myBuildTree(0, n - 1, 0, n - 1)
```

## K个一组翻转链表

```python
class Solution:
    # 翻转一个子链表，并且返回新的头与尾
    def reverse(self, head: ListNode, tail: ListNode):
        prev = tail.next
        curr = head
        while prev != tail:
            nex = curr.next
            curr.next = prev
            prev = curr
            curr = nex
        return tail, head

    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        hair = ListNode(0)
        hair.next = head
        pre = hair

        while head:
            tail = pre
            # 查看剩余部分长度是否大于等于 k
            for i in range(k):
                tail = tail.next
                if not tail:
                    return hair.next
            nex = tail.next
            head, tail = self.reverse(head, tail)
            # 把子链表重新接回原链表
            pre.next = head
            tail.next = nex
            pre = tail
            head = tail.next
        
        return hair.next
```

## 买卖股票的最佳时机

**最佳时机I**

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

显然，如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。

因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        minprice = float('inf')
        maxprofit = 0
        for price in prices:
            maxprofit = max(price - minprice, maxprofit)
            minprice = min(price, minprice)
        return maxprofit
```

**最佳时机2**

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for (int i = 1; i < n; ++i) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
}
```

**最佳时机3**

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        buy1 = buy2 = -prices[0]
        sell1 = sell2 = 0
        for i in range(1, n):
            buy1 = max(buy1, -prices[i])
            sell1 = max(sell1, buy1 + prices[i])
            buy2 = max(buy2, sell1 - prices[i])
            sell2 = max(sell2, buy2 + prices[i])
        return sell2
```

## 二叉树前中后序遍历，层序遍历

```python
import copy
class node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

# 简单的非递归实现二叉树的前序遍历  root -> left -> right
def preOrder_easy(root):
    res, stack = [], [root]
    while stack:
        root = stack.pop()
        if type(root) is node:
            if root.right:
                stack.append(root.right)
            if root.left:
                stack.append(root.left)
            stack.append(root.val)
        else:
            res.append(root)
    return res

preOrder_easy(copy.deepcopy(root))

# 后序遍历的非递归实现  left -> right -> root
def postOrder_easy(root):
    res, stack = [], [root]
    while stack:
        root = stack.pop()
        if type(root) is node:
            stack.append(root.val)
            if root.right:
                stack.append(root.right)
            if root.left:
                stack.append(root.left)
        else:
            res.append(root)
    return res
postOrder_easy(copy.deepcopy(root))

# 中序遍历非递归的简单实现   left -> root -> right
def inOrder_easy(root):
    res, stack = [], [root]
    while stack:
        root = stack.pop()
        if type(root) is node:
            if root.right:
                stack.append(root.right)
            stack.append(root.val)
            if root.left:
                stack.append(root.left)
        else:
            res.append(root)
    return res
inOrder_easy(copy.deepcopy(root))

# 层序遍历非递归实现记得不是采用栈而是采用队列，先进先出的数据结构，这样都是从左往右一层一层打印
def leverOrder_easy(root):
    res, queue = [], [root]
    while queue:
        curr = queue.pop(0)
        res.append(curr.val)
        if curr.left:
            queue.append(curr.left)
        if curr.right:
            queue.append(curr.right)
    return ans

# 递归实现最为简单，根据出现的顺序递归就好了，反而上面的栈实现主要栈是后进先出所以顺序要反过来
def preOrder_recur(root):
    if not root:
        return []
    return preOrder_recur(root.val) + preOrder_recur(root.left) + preOrder_recur(root.right)

def inOrder_recur(root):
    if not root:
        return []
    return inOrder_recur(root.left) + [root.val] + inOrder_recur(right)

def postOrder_recur(root):
    if not root:
        return []
    return postOrder_recur(root.left) + postOrder_recur(root.right) + postOrder_recur(root.val)

def levelOrder_recur(root):
    ans = [[]]  # 初始化时候就要添加一个二级列表，这样新层的第一个元素的值就有空间可以存储，相应的返回答案的时候不要最后一行
    def recursion(curr, level):
        if not curr:
            return 
        else:
            ans[level-1].append(curr.val)
            if len(ans) == level:
                ans.append([])  # 为下一层准备
            recursion(curr.left, level+1)  # 不用判断是否存在子结点再递归，递归的时候会先判断的
            recursion(curr.right, level+1)
    recursion(root, 1)
    return ans[:-1]
```

## 二叉树转链表

```python
给定一个二叉树，原地将它展开为一个单链表。
例如，给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6
1
2
3
4
5
将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
可以发现顺序刚好是二叉树的前序遍历顺序，前序遍历先访问左子树，所以不能将左指针用来连接链表，于是采用右指针来当做链表的指针
然后非递归实现的时候，先入右结点，这样的话刚好右指针被保存起来，用来链接连接链表，所以前序遍历非递归实现刚好可以原地将二叉树转为单链表
# 存一个辅助结点来表示上一个结点，这样遍历到下一个结点的时候可以让上一个结点的右指针指向自己
helpNode = None
def binTree_link(root):
    stack = [root]
    while stack:
        curr = stack.pop()
        if curr.right:
            stack.append(curr.right)
        if curr.left:
            stack.append(curr.left)
        if helpNode:
            helpNode.right = curr
            helpNode.left = None
        helpNode = curr
    return root
```

## 用两个栈实现队列

把所有数据往栈1插入，然后所有数据往栈2插入，出来的结果就是队列的效果，当然中途临时加元素，只能所有数据从栈2出来之后再重复之前的操作（比较无聊的问题）

## 数组逆序对计算

利用归并排序计算数组里不同的逆序对数，时间复杂度O(nlogn)

```python
def merge_count(list):
    if len(list) <= 1:
        return list, 0
    mid = len(list) // 2
    left_li,left_cont = merge_count(list[:mid])
    right_li,right_cont = merge_count(list[mid:])
    count = left_cont + right_cont

    result = []
    while 0 < len(left_li) and 0 < len(right_li):
        if left_li[0] > right_li[0]:
            result.append(left_li.pop(0))
            count += len(right_li)
        else:
            result.append(right_li.pop(0))
    result += left_li
    result += right_li
    return result, count
```

## 在有重复的升序数组中寻找特定的数的下标，如果有多个符合，返回最小下标，不在数组中返回-1

二分查找，记录下标

```python
def search(nums, target):
    ans = -1
    def recursive(left, right): 
        if left < 0 or right >= len(nums) or left > right:
            return
        mid = (right - left + 1) // 2 + left
        if nums[mid] == target:
            while mid-1 >= 0 and nums[mid-1] == target:
                mid -= 1
            nonlocal ans
            ans = mid
            return 
        recursive(left, mid-1)
        recursive(mid+1, right)
    recursive(0, len(nums)-1)
    return ans
print(search([1, 2, 4, 4, 5], 1))
```

## 全排列实现

递归实现

```python
def permutations(arr, position, end):
    if position == end:
        print(arr)
        return
    else:
        for index in range(position, end):
            # swap value
            arr[index], arr[position] = arr[position], arr[index]
            permutations(arr, position+1, end)
            # swap again
            arr[index], arr[position] = arr[position], arr[index]
 
arr = ["a","b","c"]
permutations(arr, 0, len(arr))
```

深度优先搜索回溯

```python
arr = ["a","b","c"]
n = len(arr)
visit = [True] * n  # choose if True
temp = [""] * n
def dfs(position):
    if position == n:
        print(temp)
        return
    for index in range(n):
        if visit[index] == True:
            temp[position] = arr[index]
            visit[index] = False
            dfs(position + 1)
            visit[index] = True
 
dfs(0)
```

## 最长回文子串

```python
# 动态递归，时间n方，空间n方
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        ans = ""
        # 枚举子串的长度 l+1
        for l in range(n):
            # 枚举子串的起始位置 i，这样可以通过 j=i+l 得到子串的结束位置
            for i in range(n):
                j = i + l
                if j >= len(s):
                    break
                if l == 0:
                    dp[i][j] = True
                elif l == 1:
                    dp[i][j] = (s[i] == s[j])
                else:
                    dp[i][j] = (dp[i + 1][j - 1] and s[i] == s[j])
                if dp[i][j] and l + 1 > len(ans):
                    ans = s[i:j+1]
        return ans

# 朴素的思想，回文子串一定是以中间为中心，两边对称，分为奇数长对称和偶数长对称分别讨论即可，时间n方，没有额外开辟空间
class Solution:
    def expandAroundCenter(self, s, left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return left + 1, right - 1  # 停止的时候是不对称的两端，返回的时候要消去

    def longestPalindrome(self, s: str) -> str:
        start, end = 0, 0
        for i in range(len(s)):
            left1, right1 = self.expandAroundCenter(s, i, i)
            left2, right2 = self.expandAroundCenter(s, i, i + 1)
            if right1 - left1 > end - start:
                start, end = left1, right1
            if right2 - left2 > end - start:
                start, end = left2, right2
        return s[start: end + 1]

```

## LRU替换算法实现

字典+双向链表实现

字典KV对应key，value存储的不是真正的值，而是对应在双向链表中的结点，结点再存储真正的val值。

## 卡特兰数

<img src="./shortcuts/image-20210408093403685.png" alt="image-20210408093403685" style="zoom: 80%;" />

### 经典的卡特兰数问题

### 括号匹配问题

- ![[公式]](https://www.zhihu.com/equation?tex=n) 个左括号， ![[公式]](https://www.zhihu.com/equation?tex=n) 个右括号，对于每一个位置，左括号数大于等于右括号数的方案总数。

- 等价于 ![[公式]](https://www.zhihu.com/equation?tex=n) 个 ![[公式]](https://www.zhihu.com/equation?tex=1) ， ![[公式]](https://www.zhihu.com/equation?tex=n) 个 ![[公式]](https://www.zhihu.com/equation?tex=-1) ，每个位置前缀和大于等于 ![[公式]](https://www.zhihu.com/equation?tex=0) 的方案总数。

- 两种理解方向：

- - ![[公式]](https://www.zhihu.com/equation?tex=f%5Bn%5D%3D%5Csum%5Climits_%7Bi%3D0%7D%5E%7Bn-1%7Df%5Bi%5Df%5Bn-1-i%5D)*。*枚举第一次前缀和为 ![[公式]](https://www.zhihu.com/equation?tex=0) 的位置，假如第 ![[公式]](https://www.zhihu.com/equation?tex=2x) 个点为第一次前缀和为 ![[公式]](https://www.zhihu.com/equation?tex=0) 的点，则固定第一个数为 ![[公式]](https://www.zhihu.com/equation?tex=1) ，第 ![[公式]](https://www.zhihu.com/equation?tex=x) 个数为 ![[公式]](https://www.zhihu.com/equation?tex=-1) ，则对答案贡献为 ![[公式]](https://www.zhihu.com/equation?tex=f%5Bx-1%5D%2Af%5Bn-x%5D) 。
  - ![[公式]](https://www.zhihu.com/equation?tex=f%5Bn%5D%3DC_%7B2n%7D%5En-C_%7B2n%7D%5E%7Bn-1%7D) 。总方案数为 ![[公式]](https://www.zhihu.com/equation?tex=C_%7B2n%7D%5En) ，现需求不符合条件的方案数，将问题转化为网格上的折线问题。第 ![[公式]](https://www.zhihu.com/equation?tex=i) 次在 ![[公式]](https://www.zhihu.com/equation?tex=%28i%2Cj%29) 处，第 ![[公式]](https://www.zhihu.com/equation?tex=i%2B1) 次在 ![[公式]](https://www.zhihu.com/equation?tex=%28i%2B1%2Cj%2B1%29) 或 ![[公式]](https://www.zhihu.com/equation?tex=%28i%2B1%2Cj-1%29) 处，终点为 ![[公式]](https://www.zhihu.com/equation?tex=%282n%2C0%29) 。不符合条件则说明折线上出现了 ![[公式]](https://www.zhihu.com/equation?tex=%28x%2C-1%29) 这个点， ![[公式]](https://www.zhihu.com/equation?tex=x) 为第一次到达 ![[公式]](https://www.zhihu.com/equation?tex=-1) 的点，我们将 ![[公式]](https://www.zhihu.com/equation?tex=x) 点之后的折线沿 ![[公式]](https://www.zhihu.com/equation?tex=y%3D-1) 对称过来，则终点为 ![[公式]](https://www.zhihu.com/equation?tex=%282n%2C-2%29) ，则一共有 ![[公式]](https://www.zhihu.com/equation?tex=n-1) 个 ![[公式]](https://www.zhihu.com/equation?tex=1) ， ![[公式]](https://www.zhihu.com/equation?tex=n%2B1) 个 ![[公式]](https://www.zhihu.com/equation?tex=-1) ，即不合法的方案总数为 ![[公式]](https://www.zhihu.com/equation?tex=C_%7B2n%7D%5E%7Bn-1%7D) ，因此 ![[公式]](https://www.zhihu.com/equation?tex=f%5Bn%5D%3DC_%7B2n%7D%5En-C_%7B2n%7D%5E%7Bn-1%7D) 。

<img src="https://pic1.zhimg.com/80/v2-7239cd587cc59c3fccca198728c1d220_1440w.jpg" alt="img" style="zoom: 33%;" />

### 出栈次序问题

- 一个无穷大的栈，进栈序列为 ![[公式]](https://www.zhihu.com/equation?tex=1%2C2%2C3...n) ，求有多少个不同的出栈序列。

### 多边划分为三角形问题

- 将一个凸多边形区域分成三角形区域的方案数。
- 在圆上选择 ![[公式]](https://www.zhihu.com/equation?tex=2%2An) 个点，将这些点对连接起来使得所得到的 ![[公式]](https://www.zhihu.com/equation?tex=n) 条线段不想交的方案数。

### 二叉树计数问题

- 给定 ![[公式]](https://www.zhihu.com/equation?tex=n) 个节点，能构成多少种形状不同的二叉树。
- 先取一个点作为顶点，然后左边依次可以取 ![[公式]](https://www.zhihu.com/equation?tex=0%EF%BD%9En-1) 个点，右边则可以取 ![[公式]](https://www.zhihu.com/equation?tex=n-1%EF%BD%9E0) 个点，相乘再累加即可得到答案。

## 海盗分金问题

经济学上有个“海盗分金”模型：是说5个[海盗](https://baike.baidu.com/item/海盗/161939)抢得100枚金币，他们按抽签的顺序依次提方案：首先由1号提出分配方案，然后5人表决，投票要超过半数同意方案才被通过，否则他将被扔入大海喂鲨鱼，依此类推。“海盗分金”其实是一个高度简化和[抽象](https://baike.baidu.com/item/抽象/82058)的模型，体现了[博弈](https://baike.baidu.com/item/博弈/74592)的思想。在“海盗分金”模型中，任何“分配者”想让自己的方案获得通过的关键是事先考虑清楚“挑战者”的分配方案是什么，并用最小的代价获取最大收益，拉拢“挑战者”分配方案中最不得意的人们。

### 假设前提

假定“每个海盗都是绝顶聪明且很理智”，那么“第一个海盗提出怎样的分配方案才能够使自己的收益最大化？”

### 推理过程

推理过程是这样的：

从后向前推，如果1至3号强盗都喂了[鲨鱼](https://baike.baidu.com/item/鲨鱼/40174)，只剩4号和5号的话，5号一定投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号惟有支持3号才能保命。

3号知道这一点，就会提出“100，0，0”的分配方案，对4号、5号一毛不拔而将全部金币归为已有，因为他知道4号一无所获但还是会投赞成票，再加上自己一票，他的方案即可通过。

不过，2号推知3号的方案，就会提出“98，0，1，1”的方案，即放弃3号，而给予4号和5号各一枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望他出局而由3号来分配。这样，2号将拿走98枚金币。

同样，2号的方案也会被1号所洞悉，1号并将提出（97，0，1，2，0）或（97，0，1，0，2）的方案，即放弃2号，而给3号一枚金币，同时给4号（或5号）2枚金币。由于1号的这一方案对于3号和4号（或5号）来说，相比2号分配时更优，他们将投1号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入囊中。这无疑是1号能够获取最大收益的方案了！答案是：1号强盗分给3号1枚金币，分给4号或5号强盗2枚，自己独得97枚。**分配方案可写成（97，0，1，2，0）或（97，0，1，0，2）**。

## 布隆过滤器

直观的说，bloom算法类似一个hash set，用来判断某个元素（key）是否在某个集合中。
和一般的hash set不同的是，这个算法无需存储key的值，对于每个key，只需要k个比特位，每个存储一个标志，用来判断key是否在集合中。

算法：
\1. 首先需要k个hash函数，每个函数可以把key散列成为1个整数
\2. 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0
\3. 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1
\4. 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。

**优点：不需要存储key，节省空间**

**缺点：**
**\1. 算法判断key在集合中时，有一定的概率key其实不在集合中**
**\2. 无法删除**

典型的应用场景：
某些存储系统的设计中，会存在空查询缺陷：当查询一个不存在的key时，需要访问慢设备，导致效率低下。
比如一个前端页面的缓存系统，可能这样设计：先查询某个页面在本地是否存在，如果存在就直接返回，如果不存在，就从后端获取。但是当频繁从缓存系统查询一个页面时，缓存系统将会频繁请求后端，把压力导入后端。

这时只要增加一个bloom算法的服务，后端插入一个key时，在这个服务中设置一次
需要查询后端时，先判断key在后端是否存在，这样就能避免后端的压力。

## 卡诺图（38译码器）

**有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有 10 只小白鼠和一星期的时间，如何检验出哪个瓶子里有毒药？**

根据2^10=1024，所以10个老鼠可以确定1000个瓶子具体哪个瓶子有毒。具体实现跟3个老鼠确定8个瓶子原理一样。
000=0
001=1
010=2
011=3
100=4
101=5
110=6
111=7
一位表示一个老鼠，0-7表示8个瓶子。也就是分别将1、3、5、7号瓶子的药混起来给老鼠1吃，2、3、6、7号瓶子的药混起来给老鼠2吃，4、5、6、7号瓶子的药混起来给老鼠3吃，哪个老鼠死了，相应的位标为1。如老鼠1死了、老鼠2没死、老鼠3死了，那么就是101=5号瓶子有毒。
同样道理10个老鼠可以确定1000个瓶子。

## 二叉树，二叉搜索树，二叉平衡树，红黑树，B树，B+树

## 1、二叉树（Binary Tree）

二叉树是每个节点最多有两个子节点的树。
二叉树的叶子节点有0个字节点，二叉树的根节点或者内部节点有一个或者两个字节点。

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODQ3NDA4LzIwMTgxMS84NDc0MDgtMjAxODExMjYyMTIxMzE1ODAtODc5NjEwMzI2LnBuZw" alt="img" style="zoom:50%;" />

## 2、二叉搜索树（Binary Search Tree）

二叉搜索树， 又叫 二叉查找树，

它或者是一棵空树，或者是具有下列性质的二叉树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树。
  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODQ3NDA4LzIwMTgxMS84NDc0MDgtMjAxODExMjYyMjM5NTg2ODUtMzQ2OTM0NzMzLnBuZw" alt="img" style="zoom:50%;" />

## 3、平衡二叉树（AVL Tree）

平衡二叉树 全称叫做 `平衡二叉搜索（排序）树`，简称 AVL树。

AVL树：二叉查找树+平衡

AVL树的特性：

- 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，
- 左右两个子树 也都是一棵平衡二叉树。

在AVL树中，任何节点的两个子树的高度最大差别为 `1` ，所以它也被称为平衡二叉树 。

**如下图：**
根节点左边高度是3，因为左边最多有3条边；右边高度而2，相差1。
根节点左边的节点50的左边是1条边，高度为1，右边有两条边，高度为2，相差1。
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODQ3NDA4LzIwMTgxMS84NDc0MDgtMjAxODExMjYyMTMyMjg5OTItMTcyMTYyNDU5Ny5wbmc" alt="img" style="zoom:50%;" />

## 4、红黑树（Red-Black Tree）

红黑树是一种含有红、黑结点，并能自平衡的二叉查找树，其性质如下：

1、每个结点或是红色的，或是黑色的
2、根节点是黑色的
3、每个叶结点（NIL）是黑色的
4、如果一个节点是红色的，则它的两个儿子都是黑色的。
5、对于每个结点，从该结点到其叶子结点构成的所有路径上的黑结点个数相同。

<img src="https://img-blog.csdnimg.cn/20190820134050324.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9qaW4yMWNlbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

## 5、B树（Balance tree）

B树，也叫 B tree、B-树、B_树。

B树是一种平衡的多路查找树、m阶树 (m>=3)

B树的定义：

1、根结点至少有两个子节点；

2、每个非叶子节点（根节点除外）最少有m/2个子节点，即内部节点的子节点个数最少也有m/2个。

3、根节点最少有两个子节点。

4、有k个关键字(关键字按递增次序排列)的非叶结点恰好有k+1个孩子。

5、所有叶子节点在同一层，即所有叶子几点高度一致。

如下图（B树的内部节点可以存放数据，类似ZK的中间节点一样。B树不是每个节点都有足够多的子节点）

<img src="https://img-blog.csdnimg.cn/20190820134105371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9qaW4yMWNlbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

## 6、B+树（B+ tree）

B+树是从B树的变体。
跟B树的不同：

1、B+树非叶子节点不存放数据，只存放keys（索引数据）。
2、B+树的叶子节点之间存在指针相连，而且是单链表。

如下图（其实B+树上二叉搜索树的扩展，二叉搜索树是每次一分为二，B树是每次一分为多）

现代操作系统中，磁盘的存储结构使用的是B+树机制，mysql的innodb引擎的存储方式也是B+树机制

<img src="https://img-blog.csdnimg.cn/20190820134121153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9qaW4yMWNlbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />