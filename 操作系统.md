## 1. 进程和线程
进程是一组线程的集合，进程是系统分配资源的基本单位，如PCB,虚拟地址空间，创建页表，维护映射，把硬盘的代码数据加载到内存，文件描述符等。

linux下线程用进程PCB模拟描述，也叫轻量级进程，是CPU调度的基本单位。

### 进程和线程的区别
进程是一组线程的集合，进程是系统分配资源的基本单位，如PCB,虚拟地址空间，创建页表，维护映射，把硬盘的代码数据加载到内存，文件描述符等。

linux下线程用进程PCB模拟描述，也叫轻量级进程，是CPU调度的基本单位。

创建销毁线程要比创建销毁进程成本低的多。（创建进程要，创建PCB,开辟虚拟地址空间，创建页表，维护映射关系，加载硬盘数据到内存，创建文件描述符，等等，而创建线程只要创建一个PCB指向进程的虚拟地址空间即可）

进程拥有自己独立的虚拟地址空间，而一个进程中的多个线程共享进程的虚拟地址空间

线程占用的资源要比进程少，线程有私有的栈结构，保存私有的数据使线程直接不相互影响

线程缺乏访问控制，进程中的一个线程出错，会终止掉整个进程，从而导致其他线程也凉凉，而一个进程出错，不会影响另一个进程


### 应用场景区别
线程应用场景：等待慢速I/O时，交给一个线程等待，接着做其他事情；通信，比较容易（注意加锁）

进程的应用场景：需要安全稳定时用进程，需要速度时用进程，既要速度又要安全

### 一个线程会产生死锁吗？
这是可能的，因为有后台线程，例如终结器线程，该线程可以在后台运行用户代码。 这允许主线程和终结器线程彼此死锁。

## 2. 死锁
死锁产生的条件

1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用。

2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。

3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。

4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。

当上述四个条件满足时，便会产生死锁

## 3. 不同的进程中的变量地址相同，会产生问题吗？
每个进程都有自己的虚拟空间地址，这里的地址不是真正的物理地址，当你在不同的进程中看到相同的地址时，其实映射的物理地址是不一样的。
当然有一个特例，共享内存，对于共享内存的话，相同的虚拟地址会映射到同样的物理地址，减少不同进程在共享数据上保存多分同样数据的空间浪费。

## 4. 进程间通信
1. 管道，又分为无名管道和有名管道，无名管道只适合用于具有亲缘关系的诸如父子、兄弟进程间通信，数据是单向流动的，类似于队列，读空或者写满都会造成堵塞，数据存放于内存中；

有名管道是无名管道的加强版本，不仅仅适合用于具有亲缘关系的进程间通信，管道名存放于文件系统中，数据存放于实际的磁盘介质或者文件系统中。

2. 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。
如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。
如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。

3. 消息队列：消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。
与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。

4. 信号量：三个操作，创建，等待，挂出

5. 共享内存

6. 套接字：可以实现跨网络间不同机器间的进程间通信


