## 1. 进程和线程
进程是一组线程的集合，进程是系统分配资源的基本单位，如PCB,虚拟地址空间，创建页表，维护映射，把硬盘的代码数据加载到内存，文件描述符等。

linux下线程用进程PCB模拟描述，也叫轻量级进程，是CPU调度的基本单位。

### 进程和线程的区别
进程是一组线程的集合，进程是系统分配资源的基本单位，如PCB,虚拟地址空间，创建页表，维护映射，把硬盘的代码数据加载到内存，文件描述符等。

linux下线程用进程PCB模拟描述，也叫轻量级进程，是CPU调度的基本单位。

创建销毁线程要比创建销毁进程成本低的多。（创建进程要，创建PCB,开辟虚拟地址空间，创建页表，维护映射关系，加载硬盘数据到内存，创建文件描述符，等等，而创建线程只要创建一个PCB指向进程的虚拟地址空间即可）

进程拥有自己独立的虚拟地址空间，而一个进程中的多个线程共享进程的虚拟地址空间

线程占用的资源要比进程少，线程有私有的栈结构，保存私有的数据使线程直接不相互影响

线程缺乏访问控制，进程中的一个线程出错，会终止掉整个进程，从而导致其他线程也凉凉，而一个进程出错，不会影响另一个进程


### 应用场景区别
线程应用场景：等待慢速I/O时，交给一个线程等待，接着做其他事情；通信，比较容易（注意加锁）

进程的应用场景：需要安全稳定时用进程，需要速度时用进程，既要速度又要安全

### 一个线程会产生死锁吗？
这是可能的，因为有后台线程，例如终结器线程，该线程可以在后台运行用户代码。 这允许主线程和终结器线程彼此死锁。

## 2. 死锁
死锁产生的条件

1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用。

2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。

3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。

4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。

当上述四个条件满足时，便会产生死锁

## 3. 乐观锁和悲观锁
悲观锁
悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。

乐观锁
乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

## 4. 进程间通信
1. 管道，又分为无名管道和有名管道，无名管道只适合用于具有亲缘关系的诸如父子、兄弟进程间通信，数据是单向流动的，类似于队列，读空或者写满都会造成堵塞，数据存放于内存中；

有名管道是无名管道的加强版本，不仅仅适合用于具有亲缘关系的进程间通信，管道名存放于文件系统中，数据存放于实际的磁盘介质或者文件系统中。

2. 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。
如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。
如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。

3. 消息队列：消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。
与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。

4. 信号量：三个操作，创建，等待，挂出

5. 共享内存

6. 套接字：可以实现跨网络间不同机器间的进程间通信


