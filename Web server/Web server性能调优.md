### **一、Web前端性能优化**

· 使用静态页面，减少后端渲染时间

· 页面优化，包括

1、减少外部文件引用，多个Http请求走同一个tcp连接，减少tcp建立连接的开销

2、 页面加载未使用的外部文件放到页面底部，通常是一些js代码

3、利用浏览器缓存

4、启用压缩

5、ajax异步加载

6、避免长cookie传输

### 二、服务器端性能优化

· 反向代理：缓存静态内容，加快用户访问速度，降低server负载压力；另外，可以采用动态内容也缓存的架构

· 注意apache web服务器MPM的选择，mpm的选择会影响httpd的速度和可扩展性

· 缓存使用，如redis集群

· 消息队列使用，如rabbitmq

· 代码优化

· 数据库读写分离，主从集群

· 数据库科学的合理的高效的索引

· 非关系型数据库的使用

· 固态磁盘的使用

### 三、布隆过滤器

#### 基本知识

布隆过滤器本质上是一种数据结构，支持高效地查询和插入，可以用来告诉你”你要验证的东西一定不存在或可能存在“。
相比于传统的列表、集合、映射等数据结构，它更高效、占用空间更少，反过来其缺点是对于存在性的判断是概率性的。

##### 实现原理

在讲布隆过滤器前，我们来讨论一下哈希，当我们想判断某个元素的存在性的时候我们经常会使用哈希将值映射到HashMap上的key, 通过该key上对应的标志
来判断存在性，时间复杂度为O(1)。但是HashMap的缺点也很明显，当存储容量占比高，考虑到负载因子的存在，通常其占用的内存空间是不能被填满的，而一旦
我们的数据量很大的时候，就会造成内存limit的问题。

##### Bloom filter 数据结构

布隆过滤器底层存储为一个0-1向量或者说0-1数组，例如有一个size大小为8的布隆过滤器，初始化全部为0：

 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
 | - | - | - | - | - | - | - | - | 
 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |

如果我们要映射一个值到布隆过滤器上，需要使用多个不同的哈希函数来生成多个哈希值，并对每个哈希值对应位置上的值置为1。
例如A通过三个不同的哈希函数求得值为1、2、5，则布隆过滤器变为：

 | 1 | 1 | 0 | 0 | 1 | 0 | 0 | 0 |
 | - | - | - | - | - | - | - | - | 
 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |

同理，此时来个B，通过设定的三个哈希函数生成值为5、7、8，则filter变为：

 | 1 | 1 | 0 | 0 | 1 | 0 | 1 | 1 |
 | - | - | - | - | - | - | - | - | 
 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |

现在，如果我们想要验证C是否存在，先通过三个哈希函数计算出值为4、7、8，而4位置上对应的值为0，则表明C是一定不存在的

但是，假如来了个D，其计算出来的三个哈希值为1、7、8，对应布隆过滤器上的值全为1，我们只能说D可能存在（在我们的例子中实际是不存在的）。
这也是Bloom filter的缺点，如果业务允许这种缺点，同时我们通过设定合适的哈希函数以及布隆向量长度，我们就可以很好的发挥布隆过滤器的优点。

##### 如何选择哈希函数个数以及确定长度

there is no doubt that长度太小时，几乎所有bit都为1，那么查询时候大概率返回“可能存在”，我们要尽可能的增加长度。另外，
哈希函数的个数也要权衡好，如果个数过多则bit位置为1会上升的很快，如果个数少了误报率就会上升。 

Best Practice最佳实践

![合适的k & m](https://images.gitee.com/uploads/images/2021/1111/152343_e82a754f_2030085.png "屏幕截图.png")
其中，k为哈希函数个数，m为长度，n为插入的元素个数，p为误报率

#### 使用场景分析

正常的查询请求， 查询redis， 再查DB，而在bloom filter方式下， 首先查询redis， 再redis， 再bloom 查询是否为有效查询， 再查询DB

1.当有大量穿透查询的场景下， redis bloom的查询成本比DB的成本低很多， 能支撑的QPS更高。可以最大程度的保护DB。

2.如果是单机部署场景下， 可以考虑内存，但是要考虑宕机或者重新部署时， bloom filter没了， 要重新构建的问题。

3.bloom filter 的核心优势就是内存消耗低， 1000万的数据， 采用google guava的hash计算方式， 在0.001的误差范围内， 消耗内存在10MB左右， 完全可以接受。

4.分布式环境下，数据放到内存中来处理， 属于典型的local cache 问题；如果想要保持一致性， 可以通过数据变更时， 群发MQ消息的方式让应用服务器实例更新。 我觉得这个方案在数据变更频次很低而访接口QPS极高时， 可以尝试。否则，当有实例 bloom filter数据未更新时， 在未更新这个间隔内， 用户请求路由到不同实例， 就会出现一下能查到，一下查不到奇怪现象。

5.接4， 如果数据变更频次很低时， 也可以考虑把bloom fliter 数据写到配置中心里， 让配置中心把数据推送到应用实例上。