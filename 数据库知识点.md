## 一、MYSQL 
### 【高频】索引
索引使用B+树结构，而不是红黑树 ： {  磁盘预读取使一个结点对应申请一个磁盘页 、红黑树高度太大 }

在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。所以一般红黑树和AVL二叉平衡查找树是内存中使用的数据结构。

【高频】mysql索引为什么使用B+树而不是 B 树？

1. b+树的数据都集中在叶子结点，分支结点只负责索引，而b树的分支结点也有数据域，
2. b+树的层高较小，平均的IO次数少于B树，减少查询时间开销
3. B+树擅长范围查询，叶子结点数据是按顺序存储在双向链表中，B树范围查询只能中序遍历


### 两种引擎之间的区别：

InnoDB：

（1）具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。

（2）支持外键，支持MVCC基于多版本的并发控制协议，不支持全文索引。

（3）InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。

（4）对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引。

（5）DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。

  **(6) 而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，所以必须有主键，如果没有显示定义，自动为生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。**

MyISAM：

（1）不支持事务操作，非事务安全的。

（2）不支持外键，不支持MVCC，支持全文索引，

（3）MyISAM保存表的具体行数，执行select count(*) from table时只要简单的读出保存好的行数即可。

（4）对于AUTO_INCREMENT类型的字段，在MyISAM表中，可以和其他字段一起建立联合索引。

（5）**MyISAM存储引擎的读锁和写锁是互斥的，读写操作是串行的**。那么，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前！这是因为MySQL认为写请求一般比读请求要重要。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！

 **(6) MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。**

**事务是应用程序中一系列严密的操作，用来保证数据库的完整性。**

**MySQL中只有使用了 InnoDB 数据库引擎的数据库或表才支持事务。**

**mysql默认自动提交事务。**

### 事务特性ACID

四个特性：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。简称为 ACID 。

注意：这里原子性跟一致性需要注意的是：原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。而一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见。

### 并发事务带来的问题
<img src="./shortcuts/事务的隔离级别与三种读问题.PNG" width="400" style="zoom: 200%;" />

### MVCC基于多版本的并发控制协议（读不加锁，实现了可重复读的事务级别）

MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。
MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。

1、LBCC：Lock-Based Concurrency Control，基于锁的并发控制。

2、MVCC：Multi-Version Concurrency Control，基于多版本的并发控制协议。纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。

**在MVCC并发控制中，读操作可以分成两类**

1、快照读 (snapshot read)：读取的是记录的可见版本 ，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）。

2、当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。

如果在进行增、删、改完成之后，再去查询快照读，则此时读取到的是最新版本的数据。如果是在增、删、改之前进行了快照读，在增、删、改之后继续快照读，则读到的就是旧版本数据。

**InnoDB如何在RR隔离界别下避免幻读——next-key锁**
**其实，真正实现RR隔离级别下的幻读现象，是由next-key锁解决的。next-key锁（行锁 + gap锁）**
**1、行锁就是Record Lock，就是对单个行记录加的锁。X锁和S锁就是行锁。**
**2、Gap就是索引树种，插入新数据的间隙。间隙锁即锁定一个记录的范围，但是不锁定记录本身。间隙锁是为了避免同一事务的两次当前读出现幻读的情况。需要注意的是，Gap锁在RU、RC隔离级别下是不存在的，在RR、Serializable隔离级别下都只支持Gap锁。这就是为什么RU、RC隔离级别下无法避免幻读，RR、Serializable能够避免幻读的原因。**


### mysql日志系统：
#### binlog
binlog 用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。binlog 是 mysql的逻辑日志，并且由 Server 层进行记录，使用任何存储引擎的 mysql 数据库都会记录 binlog 日志。

逻辑日志：可以简单理解为记录的就是sql语句 。

物理日志：mysql 数据最终是保存在数据页中的，物理日志记录的就是数据页变更 。

binlog 是通过追加的方式进行写入的，可以通过max_binlog_size 参数设置每个 binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。

binlog使用场景
在实际应用中， binlog 的主要使用场景有两个，分别是 主从复制 和 数据恢复 。

主从复制 ：在 Master 端开启 binlog ，然后将 binlog发送到各个 Slave 端， Slave 端重放 binlog 从而达到主从数据一致。

数据恢复 ：通过使用 mysqlbinlog 工具来恢复数据。

#### redo log
只记录事务对数据页做了哪些修改, 性能提升，mysql对数据的修改不是马上执行的，会写入os buffer然后再刷新进入磁盘。通过redo log实现崩溃修复。

实现持久性

#### undo log
回滚，实现原子性。

- 1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据
- (2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作
- (3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操

undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。

### 乐观锁和悲观锁
**悲观锁**
悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。

**乐观锁**
乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，**但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据**。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

**实现乐观锁：**

乐观锁假设认为数据一般情况下不会产生并发冲突，所以在数据进行提交更新的时候，才会正式对数据是否产生并发冲突进行检测，如果发现并发冲突了，则让返回用户错误的信息，让用户决定如何去做。

（1）CAS机制：当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败。CAS 有效地说明了“ 我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可“。

（2）版本机制：CAS机制保证了在更新数据的时候没有被修改为其他数据的同步，版本机制就保证了没有被修改过，防止出现ABA问题（前后两次看到的表面结果是一样的，实际上从A->B->A，经历了中间状态B））。


### 聚簇索引和非聚簇索引区别, 主键索引和二级索引
聚簇索引(也称为主键索引)就是携带了行数据的索引,非聚簇索引就是除了聚簇索引之外的索引。因此非聚簇索引查询数据需要先查到聚簇索引的key,然后用这个key去查询真正的数据(这个过程称为回表)。所以能走聚簇索引的尽量走聚簇索引(也可以说是尽量走主键),看起来都是走索引,实际上主键要更快。但是如果要查询的字段, 数据直接就在索引上是可以不需要回表的.这种索引称为覆盖索引。
主键上的索引称为主键索引，其他索引为二级索引。


### explain中 rows type key extra字段的含义？
explain只能解释select语句

rows：sql查询时估算的要检查的行数

type：联接类型

key：显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL

extra：包含MySQL解决查询的详细信息


### count(1) count(*) count(列值)的区别
**count(1): 统计表中的所有的记录数，包含字段为null 的记录。**

count(*):包括了所有的列，相当于行数，在统计结果的时候，**不会忽略列值为NULL**  

**count(某一列)：只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。**

列名为主键，count(列名)会比count(1)快  

列名不为主键，count(1)会比count(列名)快  

如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）  

如果有主键，则 select count（主键）的执行效率是最优的  

**如果表只有一个字段，则 select count（*）最优。**

### UNION ALL 与 UNION 的区别

- UNION和UNION ALL关键字都是将两个结果集合并为一个。
- UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。
- 而UNION ALL只是简单的将两个结果合并后就返回。
- 由于UNION需要排序去重，所以 UNION ALL 的效率比 UNION 好很多。

### TRUNCATE 与 DELETE 区别

- TRUNCATE 是DDL语句，而 DELETE 是DML语句。
- TRUNCATE 是先把整张表drop调，然后重建该表。而 DELETE 是一行一行的删除，所以 TRUNCATE 的速度肯定比 DELETE 速度快。
- TRUNCATE 不可以回滚，DELETE 可以。
- TRUNCATE 执行结果只是返回0 rows affected，可以解释为没有返回结果。
- TRUNCATE 会重置水平线（自增长列起始位），DELETE 不会。
- TRUNCATE 只能清理整张表，DELETE 可以按照条件删除。

一般情景下，TRUNCATE性能比DELETE好一点。

### TIMESTAMP 与 DATETIME 的区别

**相同点**

TIMESTAMP 列的显示格式与 DATETIME 列相同。显示列宽固定在19字符，并且格式为YYYY-MM-DD HH:MM:SS。

**不同点**

TIMESTAMP

- 4个字节存储，时间范围：1970-01-01 08:00:01~2038-01-19 11:14:07。
- 值以UTC格式保存，涉及时区转化，存储时对当前的时区进行转换，检索时再转换回当前的时区。

DATETIME

- 8个字节存储，时间范围：1000-10-01 00:00:00~9999-12-31 23:59:59。
- 实际格式存储，与时区无关。

### 自增键相关知识点

**可重复读事务级别下，插入数据，自增键不一定是连续递增的，即出现自增空洞，有三种情况可能造成自增空洞：**

- 在 0, 1, 2 三种任何模式下，如果事务回滚，那么里面获**得自增值的sql回滚，但产生的自增值会一起丢失，不可能重新分配给其它insert语句。这也会产生空洞**。

- 在大块插入情景下：

  innodb_autoinc_lock_mode为 **0 或 1 时**，因为 AUTO-INC 锁会持续到语句结束，同一时间只有一个 语句 在表上执行，所以自增值是连续的（其它事务需要等待），不会有空洞；
  **innodb_autoinc_lock_mode为 2 时，两个 “大块插入” 之间可能会有空洞，因为每条语句事先无法预知精确的数量而导致分配过多的id，可能有空洞。**

- 执行delete删除表，重新插入会继续增加，不会从新开始增加；如果想删除表数据后，从新计算自增值，可以采用truncate。

**一：insert into t1(name)values(“zhangsan”),(“lisi”),(“wangwu”); 这类简单插入，当有并发事务执行时，自增键仍能保证连续性，是如何做到的？**

A： 行粒度加锁，实施互斥
B： 表粒度加锁，实施互斥
C： 全局自增键单例，实施互斥
**D： SQL语句粒度加锁，实施互斥**
E： 事务粒度加锁，实施互斥
**答案选D(以MySQL8为准，如果是之前的版本，选C)**

二：基于SQL复制的主从同步，如果执行并发批量插入(bulk insert)事务，“可能”出现同一个事务的自增键不连续，那么能否保证主从数据的一致性？如果能，是怎么保证的？

**可以将自增模式innodb_autoinc_lock_mode设置为0。**

三：MySQL的自增ID用完了，再插入的时候，怎么样？

**数据库表的自增 ID 达到上限之后，再申请时它的值就不会在改变了，继续插入数据时会导致报主键冲突错误。**

四：带AUTO_INCREMENT约束的字段值是从1开始的吗？

默认的，在MySQL中，AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT)的时候，还可以指定第一条插入记录的自增字段的 值，这样新插入的记录的自增字段值从初始值开始递增。添加唯一性的主键约束时， 往往需要设置字段自动增加属性。

### 联合索引在where条件中的不同作用情况

<img src="./shortcuts/1616823521-MyZzJz-索引是否使用的情况.png" alt="img" style="zoom:150%;" />

**总的来说，对于联合索引，如果没有使用到第一个字段的话是不会使用索引来优化查询的，同时，对于字段的模糊匹配时，通配符不能出现在首部。**

### 联合索引底层存储结构

单列索引其实也可以看做联合索引，索引列为一个列的联合索引。联合索引的底层存储跟单列索引是类似的，区别在于联合索引是每个树节点中包含多个索引值，在通过联合索引查找记录时，**会先将联合索引中第一个索引列与节点中第一个索引值进行匹配，匹配成功接着匹配第二个索引列和索引值，直到联合索引的所有索引列都匹配完；如果过程中出现某一个索引列与节点相应位置的索引值不匹配的情况，则无需再匹配节点中剩余索引列，前往下一个节点。**

### 为什么要使用联合索引

- **减少开销：**建一个[联合索引](http://mp.weixin.qq.com/s?__biz=MzU2MTI4MjI0MQ%3D%3D&chksm=fc7a785fcb0df14916e0fe9bf823fba0443a4409e79935baa0f409bd44255054824b2c32eb26&idx=2&mid=2247489009&scene=21&sn=b548bbcbd7e716e866d6d62962eda602#wechat_redirect)(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。减少磁盘空间的开销。
- **覆盖索引：**对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。覆盖索引是主要的提升性能的优化手段之一。
- **效率高：**索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql `select from table where col1=1 and col2=2 and col3=3`，假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出`1000W * 10%=100w`条数据，然后再回表从100w条数据中找到符合`col2=2 and col3= 3`的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出`1000w * 10% * 10% * 10%=1w`，效率得到明显提升。

### 索引什么时候该用，什么时候不该用

查询多的时候该建立索引，最好是高效合理的索引，索引不是越多越好，不然额外成本越多

增删改多的时候不要建索引，增删改时候如果存在索引要重新建立索引

### 主从同步策略有哪些，insert到master是等同步完成再响应还是？

#### 1.半同步复制

办法就是等主从同步完成之后，等主库上的写请求再返回，这就是常说的“半同步复制”。

实现方案

MySQL的Replication默认是一个异步复制的过程，从MySQL 5.5开始，MySQL以插件的形式支持半同步复制，我先谈下异步复制，这样可以更好的理解半同步复制。

1）异步复制

MySQL默认的复制是异步的，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主上已经提交的事务可能并没有传到从库上。

2）半同步复制

**介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay**
**log中才返回给客户端**。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。

半同步复制原理：

事务在主库写完binlog后需要从库返回一个已接受，才放回给客户端。
mysql5.5版本以后，以插件的形式存在，需要单独安装，确保事务提交后binlog至少传输到一个从库，不保证从库应用完成这个事务的binlog。性能有一定的降低，网络异常或从库宕机，卡主库，直到超时或从库恢复。
该方案优点：利用数据库原生功能，比较简单

该方案缺点：主库的写请求时延会增长，吞吐量会降低

**2.数据库中间件**

流程：

1）所有的读写都走数据库中间件，通常情况下，写请求路由到主库，读请求路由到从库

2）记录所有路由到写库的key，在主从同步时间窗口内（假设是500 ms），如果有读请求访问中间件，此时有可能从库还是旧数据，就把这个key上的读请求路由到主库。

3）在主从同步时间过完后，对应key的读请求继续路由到从库。
**insert等增删改到master是等同步完成再响应还是怎样，是我们采取的同步策略来决定的，当然一般情况下是同步完成再响应，可以采用数据中间件的解决方案。**

### 慢查询SQL

**怎么定义慢查询**

 慢查询是指执行时间超过慢查询时间的sql语句。

**调慢查询SQL有什么经验**

产生慢查询的原因根据概率从大到小罗列如下：

1. **SQL编写问题**

   正确的使用索引能加快查询速度，那么我们在编写 SQL 时就需要注意与索引相关的规则：

   字段类型转换导致不用索引，如字符串类型的不用引号，数字类型的用引号等，这有可能会用不到索引导致全表扫描；

   mysql 不支持函数转换，所以字段前面不能加函数，否则这将用不到索引；

   不要在字段前面加减运算；

   字符串比较长的可以考虑索引一部份减少索引文件大小，提高写入效率；

   **like % 在前面用不到索引；**

   联合索引的第二个及以后的字段单独查询用不到索引；

   不要使用 select *；

   排序请尽量使用升序 ;

   **or 的查询尽量用 union 代替 （InnoDB）；**

   复合索引高选择性的字段排在前面；

   order by / group by 字段包括在索引当中减少排序，效率会更高。

2. **锁**

3. **业务实例相互干绕对 IO/CPU 资源争用**

4. **服务器硬件**

5. **MYSQL BUG**

### sql语句执行顺序比较

查询中用到的关键词主要包含六个，并且他们的顺序依次为：
select>from>where>group by>having>order by

其中select和from是必须的，其他关键词是可选的，这六个关键词的执行顺序与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行：
from>where>group by>having>select>order by

**什么叫做覆盖索引？**

解释一： 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。

解释二： 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。解释三：是非聚集组合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段，也即，索引包含了查询正在查找的所有数据）。不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引的列，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引当发起一个被索引覆盖的查询(也叫作索引覆盖查询)时，在EXPLAIN的Extra列可以看到“Using index”的信息。

注：遇到以下情况，执行计划不会选择覆盖查询。

select选择的字段中含有不在 索引 中的字段 ，即索引没有覆盖全部的列。where条件中不能含有对索引进行like的操作。

**mysql聚集索引，辅助索引，联合索引，覆盖索引**

**聚集索引：**一个表中只能有一个，聚集索引的顺序与数据真实的物理存储顺序一致。查询速度贼快，聚集索引的叶子节点上是该行的所有数据 ，数据索引能加快范围查询(聚集索引的顺序和数据存放的逻辑顺序一致)。**主键!=聚集索引，主键索引是聚集索引。**

**辅助索引(非聚集索引)：一个表中可以有多个，叶子节点存放的不是一整行数据，而是键值，叶子节点的索引行中还包含了一个'书**签'，这个书签就是指向聚簇索引的一个指针，从而在聚簇索引树中找到一整行数据。

**联合索引：**就是由多列组成的的索引。遵循最左前缀规则。对where，order by，group by 都生效。

**覆盖索引：**指从辅助索引中就能获取到需要的记录，而不需要查找聚簇索引中的记录。使用覆盖索引的一个好处是因为辅助索引不包括一条记录的整行信息，所以数据量较聚集索引要少，可以减少大量io操作。

**聚集索引与辅助索引的区别：**叶子节点是否存放的为一整行数据

**最左前缀规则：**假设联合索引由列(a,b,c)组成，则一下顺序满足最左前缀规则：a、ab、abc；selece、where、order by 、group by都可以匹配最左前缀。其它情况都不满足最左前缀规则就不会用到联合索引。

### **二级索引回表的过程**

非主键索引就是二级索引

##### 回表：由于二级索引中并没有存储其他字段的信息（只存储了索引对应字段的信息），所以为了拿到其他数据，`必须拿着查到的id信息 到聚簇索引中再次根据id查找。这个过程称为回表。`

## 二、TiDB 架构

TiDB 具有无限水平扩展和高可用性的特点，通过简单地增加新节点即可实现计算和存储能力的扩展，轻松地应对高并发、海量数据的应用场景。

TiDB 的整体架构参考 Google Spanner/F1 的设计，也分为 **TiDB 和 TiKV** 上下两层。

TiDB 对应的是Google F1，是一层无状态的 SQL 层，负责与客户端交互，对客户端体现的是 MySQL 网络协议，且客户端需要通过一个本地负载均衡器将 SQL 请求转发到本地或最近的数据中心中的 TiDB 服务器。

TiDB 服务器负责解析用户的 SQL 语句，生成分布式的查询计划，并翻译成底层 Key-Value 操作发送给 TiKV，而 TiKV 则是真正存储数据的地方，对应的是 Google Spanner，是一个分布式 Key-Value 数据库，支持弹性水平扩展、 自动的灾难恢复和故障转移，以及 ACID 跨行事务。

另外，TiDB 架构采用 PD 集群来管理整个分布式数据库，**PD 服务器在** TiKV 节点之间以 Region 作为单位进行调度，将部分数据迁移到新添加的节点上，完成集群调度和负载均衡。

TiDB 的集群架构如下图所示。

<img src="http://c.biancheng.net/uploads/allimg/191120/6-191120153I4c6.gif" alt="img" style="zoom:150%;" />

### TiDB有没有用到乐观锁？

TiDB 使用 Percolator 事务模型，实现了分布式事务，其中提供了两种事务模式，乐观事务和悲观事务，所以对于TiDB有可能使用乐观锁，也有使用悲观锁的时候。

## 三、WAL

WAL即 Write Ahead Log，WAL的主要意思是说在将元数据的变更操作写入磁盘之前，先预先写入到一个log文件中。

数据库数据写入到磁盘的过程：

1. 客户端向数据库发送写命令。
2. 数据库收到写命令。
3. 数据库通过系统调用将数据写入内核缓冲区（page cache，内存中用来缓存磁盘数据的区域)。
4. 操作系统将缓冲区数据传输至磁盘控制器，暂存在磁盘缓冲区。
5. 磁盘控制器将数据精准的写入物理磁盘。

可见，在这个过程中出现的故障会造成数据并没有真正的写入磁盘，同时如果每次更新的数据都对应一次磁盘数据页的修改，性能是非常低的。

### WAL原理

- 通过cache合并多条写操作为一条，减少IO次数
- 日志顺序追加性能远高于数据随机写。

### MySQL WAL应用

```
MySQL通过redolog、undolog实现事务的原子性和持久化。
```

当然，在HBase等也有对应的WAL思想原理的实现方案。

![img](https://loufengman.github.io//2020/02/26/WAL%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/hbase.png)