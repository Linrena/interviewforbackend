### **一、Web前端性能优化**

· 使用静态页面，减少后端渲染时间

· 页面优化，包括

1、减少外部文件引用，多个Http请求走同一个tcp连接，减少tcp建立连接的开销

2、 页面加载未使用的外部文件放到页面底部，通常是一些js代码

3、利用浏览器缓存

4、启用压缩

5、ajax异步加载

6、避免长cookie传输

### 二、服务器端性能优化

· 反向代理：缓存静态内容，加快用户访问速度，降低server负载压力；另外，可以采用动态内容也缓存的架构

· 注意apache web服务器MPM的选择，mpm的选择会影响httpd的速度和可扩展性

· 缓存使用，如redis集群

· 消息队列使用，如rabbitmq

· 代码优化

· 数据库读写分离，主从集群

· 数据库科学的合理的高效的索引

· 非关系型数据库的使用

· 固态磁盘的使用

### 三、布隆过滤器

#### 基本知识

布隆过滤器本质上是一种数据结构，支持高效地查询和插入，可以用来告诉你”你要验证的东西一定不存在或可能存在“。
相比于传统的列表、集合、映射等数据结构，它更高效、占用空间更少，反过来其缺点是对于存在性的判断是概率性的。

##### 实现原理

在讲布隆过滤器前，我们来讨论一下哈希，当我们想判断某个元素的存在性的时候我们经常会使用哈希将值映射到HashMap上的key, 通过该key上对应的标志
来判断存在性，时间复杂度为O(1)。但是HashMap的缺点也很明显，当存储容量占比高，考虑到负载因子的存在，通常其占用的内存空间是不能被填满的，而一旦
我们的数据量很大的时候，就会造成内存limit的问题。

##### Bloom fliter 数据结构

布隆过滤器底层存储为一个0-1向量或者说0-1数组

| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |

#### 使用场景分析

正常的查询请求， 查询redis， 再查DB，而在bloom filter方式下， 首先查询redis， 再redis， 再bloom 查询是否为有效查询， 再查询DB

1.当有大量穿透查询的场景下， redis bloom的查询成本比DB的成本低很多， 能支撑的QPS更高。可以最大程度的保护DB。

2.如果是单机部署场景下， 可以考虑内存，但是要考虑宕机或者重新部署时， bloom filter没了， 要重新构建的问题。

3.bloom filter 的核心优势就是内存消耗低， 1000万的数据， 采用google guava的hash计算方式， 在0.001的误差范围内， 消耗内存在10MB左右， 完全可以接受。

4.分布式环境下，数据放到内存中来处理， 属于典型的local cache 问题；如果想要保持一致性， 可以通过数据变更时， 群发MQ消息的方式让应用服务器实例更新。 我觉得这个方案在数据变更频次很低而访接口QPS极高时， 可以尝试。否则，当有实例 bloom filter数据未更新时， 在未更新这个间隔内， 用户请求路由到不同实例， 就会出现一下能查到，一下查不到奇怪现象。

5.接4， 如果数据变更频次很低时， 也可以考虑把bloom fliter 数据写到配置中心里， 让配置中心把数据推送到应用实例上。